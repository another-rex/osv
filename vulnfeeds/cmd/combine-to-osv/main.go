package main

import (
	"encoding/json"
	"flag"
	"log"
	"os"
	"path"

	"github.com/google/osv/vulnfeeds/cves"
	"github.com/google/osv/vulnfeeds/vulns"
)

const (
	defaultCvePath        = "cve_jsons"
	defaultPartsInputPath = "parts"
	defaultOsvOutputPath  = "osv_output"
)

func main() {
	cvePath := flag.String("cvePath", defaultCvePath, "Path to CVE file")
	partsInputPath := flag.String("partsPath", defaultPartsInputPath, "Path to CVE file")
	osvOutputPath := flag.String("osvOutputPath", defaultOsvOutputPath, "Path to CVE file")
	flag.Parse()

	err := os.MkdirAll(*cvePath, 0755)
	if err != nil {
		log.Fatalf("Can't create output path: %s", err)
	}
	err = os.MkdirAll(*osvOutputPath, 0755)
	if err != nil {
		log.Fatalf("Can't create output path: %s", err)
	}

	allCves := loadAllCVEs(*cvePath)
	allParts := loadParts(*partsInputPath)
	combinedData := combineIntoOSV(allCves, allParts)
	writeOsvFile(combinedData, *osvOutputPath)
}

// loadInnerParts loads second level folder for the loadParts function
func loadInnerParts(innerPartInputPath string, output map[string][]vulns.PackageInfo) {
	dirInner, err := os.ReadDir(innerPartInputPath)
	if err != nil {
		log.Fatalf("Failed to read dir? %s", err)
	}
	for _, entryInner := range dirInner {
		file, err := os.Open(path.Join(innerPartInputPath, entryInner.Name()))
		if err != nil {
			log.Fatalf("Failed to open cve json: %s", err)
		}
		var pkgInfos []vulns.PackageInfo
		err = json.NewDecoder(file).Decode(&pkgInfos)
		if err != nil {
			log.Fatalf("Failed to decode json: %s", err)
		}

		cveId := path.Base(entryInner.Name())
		output[cveId] = append(output[cveId], pkgInfos...)

		log.Printf("Loaded Alpine Item: %s", entryInner.Name())
		file.Close()
	}
}

// loadParts loads files generated by other executables in the cmd folder.
//
// Expects directory structure of:
// ```
// - <partsInputPath>/
//    - alpineParts/
//        - CVE-2020-1234.alpine.json
//        - ...
//    - debianParts/
//    - ...
// ```
//
// ## Returns
// A mapping of "CVE-ID": []<Affected Package Information>
func loadParts(partsInputPath string) map[string][]vulns.PackageInfo {
	dir, err := os.ReadDir(partsInputPath)
	if err != nil {
		log.Fatalf("Failed to read dir? %s", err)
	}
	output := map[string][]vulns.PackageInfo{}
	for _, entry := range dir {
		if !entry.IsDir() {
			log.Println("Unexpected file entry in " + partsInputPath)
			continue
		}
		// map is already a reference type, so no need to pass in a pointer
		loadInnerParts(path.Join(partsInputPath, entry.Name()), output)
	}
	return output
}

// combineIntoOsv creates OSV entry by combining loaded CVEs from NVD and PackageInfo information from security advisories.
func combineIntoOSV(loadedCves map[string]cves.CVEItem, allParts map[string][]vulns.PackageInfo) map[string]*vulns.Vulnerability {
	log.Println("Begin writing OSV files")
	convertedCves := map[string]*vulns.Vulnerability{}
	for vId, v := range loadedCves {
		if len(allParts[vId]) == 0 {
			continue
		}
		cve, _ := vulns.FromCVE(vId, v, allParts[vId])
		convertedCves[vId] = cve
	}
	return convertedCves
}

// writeOsvFile writes out the given osv objects into individual json files
func writeOsvFile(osvData map[string]*vulns.Vulnerability, osvOutputPath string) {
	for vId, osv := range osvData {
		file, err := os.OpenFile(path.Join(osvOutputPath, vId+".json"), os.O_CREATE|os.O_RDWR, 0644)
		if err != nil {
			log.Fatalf("Failed to create/open file to write: %s", err)
		}
		encoder := json.NewEncoder(file)
		encoder.SetIndent("", "  ")
		err = encoder.Encode(osv)
		if err != nil {
			log.Fatalf("Failed to encode OSVs")
		}
		file.Close()
	}

	log.Println("Successfully written all OSV files")
}

// loadAllCVEs loads the downloaded CVE's from the NVD database into memory.
func loadAllCVEs(cvePath string) map[string]cves.CVEItem {
	dir, err := os.ReadDir(cvePath)
	if err != nil {
		log.Fatalf("Failed to read dir? %s", err)
	}

	result := make(map[string]cves.CVEItem)

	for _, entry := range dir {
		file, err := os.Open(path.Join(cvePath, entry.Name()))
		if err != nil {
			log.Fatalf("Failed to open cve json: %s", err)
		}
		var nvdcve cves.NVDCVE
		err = json.NewDecoder(file).Decode(&nvdcve)
		if err != nil {
			log.Fatalf("Failed to decode json: %s", err)
		}

		for _, item := range nvdcve.CVEItems {
			result[item.CVE.CVEDataMeta.ID] = item
		}
		log.Printf("Loaded CVE: %s", entry.Name())
		file.Close()
	}
	return result
}
